



cfrg                                                          S. Iyengar
Internet-Draft                                                  Facebook
Intended status: Informational                          22 February 2021
Expires: 26 August 2021


   Verifiable Oblivious Pseudo-Random Functions with Public Metadata
                draft-iyengar-cfrg-voprfmetadata-latest

Abstract

   This document describes a verifable mechansim to bind public metadata
   to an existing Verifiable oblivious Pseduo-Random function
   [I-D.irtf-cfrg-voprf].  Using zero knowledge proofs a receiver can
   verify that, for an input x, a VOPRF(k, x, metadata), is generated
   from a secret key k, as well as the given metadata.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the Crypto Forum Research
   Group mailing list (cfrg@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=cfrg.

   Source for this draft and an issue tracker can be found at
   https://github.com/siyengar/verifiable-attribute-based-key-
   derivation.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 26 August 2021.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements
     1.2.  Terminology
   2.  Preliminaries
     2.1.  Prime-Order Group Dependency
     2.2.  Discrete log proofs
     2.3.  Other Conventions
   3.  Protocol
     3.1.  Overview
     3.2.  Pre-Setup
     3.3.  Evaluate VOPRF
   4.  Application considerations
     4.1.  Metadata bits
     4.2.  Encoding metadata
   5.  Comparison with other approaches
     5.1.  Pairings
     5.2.  Regular key derivation
   6.  Security Considerations
     6.1.  Cryptographic security
       6.1.1.  Hardness assumptions
     6.2.  Selective security vs full security
   7.  IANA Considerations
   8.  Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   A VOPRF allows a client and server to evaluate a psuedo-random
   function "F(k, x)", with secret key "k", and input "x" without the
   client learning the key "k" and the server learning the input "x".
   Additionally in a VOPRF, the client can verify that the output was
   computed using the key "k".

   One challenge in VOPRFs is to be able to bind public metadata to the
   output of the VOPRF while keeping the VOPRF both verifiable and
   oblivious.  Unlike the input x to the VOPRF, public metadata is not
   meant to be secret to either the client or the server.  This public
   metadata is useful in applications where being able to bind
   application context to a VOPRF output is criticial to the security of
   the application.

   In this draft we describe a mechanism to bind public metadata to a
   VOPRF by deriving the public-private keypair that is used by the
   VOPRF from the metadata [PrivateStats].  This method allows the use
   of existing elliptic curve VOPRF ciphers while only changing the way
   the secret key is derived.  Additionally, the key derivation
   mechanism of the public key can be verified by a client using non-
   interactive zero-knowledge proofs to prove that the metadata specific
   key is derived from a master secret.

   The draft does not describe how metadata is used, but that left to
   specific application protocols that use this public metadata
   mechanism.

1.1.  Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

1.2.  Terminology

   The following terms are used throughout this document.

   *  PRF: Pseudorandom Function.

   *  VOPRF: Verifiable Oblivious Pseudorandom Function.

   *  Client: Protocol initiator.  Learns pseudorandom function
      evaluation as the output of the protocol.

   *  Server: Computes the pseudorandom function over a secret key.
      Learns nothing about the client's input.

   *  NIZK: Non-interactive zero knowledge.

   *  DLEQ: Discrete Logarithm Equality.

2.  Preliminaries

   The document defines extensions to the VOPRF required to support
   metadata.  This document depends on the following:

   *  "GG": A prime-order group implementing the API described in
      [I-D.irtf-cfrg-voprf] as well as the additional APIs defined below
      in Section 2.1.

   *  "Metadata": The metadata is defined as "n" bits.

2.1.  Prime-Order Group Dependency

   We define new member functions on the prime-order group "GG" defined
   in [I-D.irtf-cfrg-voprf]:

   *  ScalarMult(point, scalar): A member function of "GG" that
      multiples an element in the group with a "scalar" from "GF(p)".

   *  NewGenerator(): A member function of "GG" that samples a new
      generator for the group.

2.2.  Discrete log proofs

   TODO: describe the discrete log proofs

2.3.  Other Conventions

   All algorithm descriptions are written in a Python-like pseudocode.
   All scalar multiplications are performed modulo "GF(p)".

3.  Protocol

3.1.  Overview

   A server first generates a main key pair "(skM, pkM)", where "skM" is
   the servers main secret key and "pkM" is the servers main public key.
   Given public metadata "t", the server generates a keypair specific to
   the metadata "t", "(skT, pkT) = PKGen(t, skM)", where "skT" is the
   secret key for metadata "t" and "pkT" is its public key.  Once a
   metadata specific keypair is available, the server can be used to
   evaluate a "VOPRF(skT, x)", where "x" is the input for the user.
   When the VOPRF is in verifiable mode, the client also receives a NIZK
   proof that "skT" and "pkT" are generated from "skM" and "pkM" (in
   verifiable mode).

   Client(pkM, input, metadata)        Server(skM, pkM, metadata)
  ----------------------------------------------------------
    blind, blindedElement = Blind(input)

                       blindedElement
                        ---------->
         skT, pkT, pkProofs = PKGen(skM, metadata)

    evaluatedElement, proof = Evaluate(skT, pkT, blindedElement)

                  evaluatedElement, pkT, proof, pkProofs
                        <----------

    pkVerified = PKVerify(pkM, pkT, pkProofs)

    output = Finalize(input, blind, evaluatedElement, blindedElement, pkT, proof)

   In the following sections we describe modifications to the VOPRF
   scheme in [I-D.irtf-cfrg-voprf] to be able to augment an existing
   VOPRF with public metadata.

3.2.  Pre-Setup

   We augment the offline context setup phase phase of the VOPRF in
   [I-D.irtf-cfrg-voprf].  In this phase, both the client and server
   create a context used for executing the online phase of the protocol.

   Prior to this phase, the key pair ("skM", "pkM") should be generated
   by using "MasterKeyGen(metadataBits)".  This keypair is used as the
   master key for VOPRFs.  This master key is not used directly within
   the VOPRF, however, public metadata is used to generate attribute
   specific keys that are used in the VOPRF evaluation.

   "metadataBits" here is the number of bits of metadata that are
   required for the application of the VOPRF.  "MasterKeyGen" samples
   "n" scalar elements "a0, a1, ... an" from the group and a new
   generator "h".  "ai" is a group element associated with the "i"th bit
   of metatadata.  Public parameters are calculated by performing scalar
   multiplicaton of "h" with each "ai".

   def MasterKeyGen(metadataBits):
       skElements = []
       pkElements = []
       h = GG.NewGroupGenerator()
       a0 = GG.RandomScalar()
       for i in range(metadataBits):
           ai = GG.RandomScalar()
           skElements.append(ai)
       for i in range(metadataBits):
           hi = GG.ScalarMult(h, skElements[i])
           pkElements.append(hi)
       P0 = GG.ScalarBaseMult(a0)
       skM = (a0, skElements)
       pkM = (GG.g, h, metadataBits, P0, pkElements)
       return (skM, pkM)

3.3.  Evaluate VOPRF

   When client and server have agreed on the metadata to use for the
   protocol, the server first executes "PKGen(skM, metadata)" to
   generate "skT" and the proof that "skT" is derived from "skM".  This
   draft does not discuss how the client and server agree on the
   metadata to use, and that is left to the application.

   Note that "skM" has one group element for each bit of the metadata
   "t", as well as the extra group element "a0".  Given metadata "t",
   "PKGen" calculates the attribute specific key by performing a scalar
   multiplication of all the group elements in "skM" for each bit of "t"
   that is set to "1".

   To prove that "skT" is derived from "skM", "GenProofs" generates upto
   "n" discrete log proofs, one for each bit of the metadata.  Each
   proof proves that "log(hi, h) == log(Pi, Pi-1)" where "log(a, b)"
   represents log a to the base b.  Since "hi = ai * h" and "Pi = ai *
   Pi-1", this proves that "ai" was correctly used for bit "i".

   def PKGen(t, skM, pkM):
       pis = []
       pi = skM.a0
       keyBits = len(metadata)
       for i in range(keyBits):
           if t[i] == 0:
               pis.append(None)
               continue
           pi = pi * skM[i]
           pis.append(pi)
       skT = pi
       pkProofs = GenProofs(metadata, pis, pkM)
       return (skT, pkProofs)

   def GenProofs(t, pis, pkM):
       proofs = []
       numProofs = len(pis)
       previousPi = pkM.P0
       for i in range(numProofs):
           if t[i] == 0:
               continue
           Pi = GG.ScalarMult(pkM.g, pis[i])
           proofi = DLEQProve(pkM.h, pkM.hi[i], previousPi, Pi)
           proofs.append(proofi)
           previousPi = Pi
       return proofs

   Once "PKGen" has generated a public key for a set of "metadata" bits,
   the client can verify that "skT" is derived from "skM", using
   "PKVerify(pkM, pkT, pkProofs)".  This verifies the sequence of
   discrete-log proofs generated by "PKGen".

   def PKVerify(pkM, pkT, t, pkProofs):
       previousPi = pkM.P0
       proofVerified = True
       for proof in pkProofs:
           if t[i] == 0:
               continue
           verified = DLEQVerify(pkM.h, pkM.hi[i], previousPi, proof)
           proofVerified = proofVerified & verified
           previousPi = proof
       return proofVerified

   A server can use "skT" generated from "PKGen" as the private key for
   the VOPRF mechanism in [I-D.irtf-cfrg-voprf].

4.  Application considerations

4.1.  Metadata bits

   Applications must choose the maximum size in bits of the metadata
   that they would like to support before setup of the protocol.  The
   size of the metdata impacts the following - Size of the public key -
   Computation time for attribute and proof generation

   For "b" being the number of metadata values needed for an
   application, the size of the public key scales as "O(log b)".
   Computation also scales as "O(log b)" number of scalar
   multiplications for generating a public key and number of discrete
   log proof generations and verifications required.

4.2.  Encoding metadata

   Applications must choose the number of bits of metadata required in
   order to be able to represent all possible values for the
   application's metadata.  They MUST define their own mechanism encode
   metadata into bits.

5.  Comparison with other approaches

5.1.  Pairings

5.2.  Regular key derivation

6.  Security Considerations

6.1.  Cryptographic security

   TODO: talk about how generating the public key binds the metadata to
   the final VOPRF evaluation.

6.1.1.  Hardness assumptions

6.2.  Selective security vs full security

7.  IANA Considerations

   This document has no IANA actions.

8.  Normative References

   [I-D.irtf-cfrg-voprf]
              Davidson, A., Faz-Hernandez, A., Sullivan, N., and C. A.
              Wood, "Oblivious Pseudorandom Functions (OPRFs) using
              Prime-Order Groups", Work in Progress, Internet-Draft,
              draft-irtf-cfrg-voprf-06, 21 February 2021,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              voprf-06.txt>.

   [PrivateStats]
              "PrivateStats, De-Identified Authenticated Logging at
              Scale", <https://research.fb.com/privatestats>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://datatracker.ietf.org/doc/html/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://datatracker.ietf.org/doc/html/rfc8174>.

Acknowledgments

   TODO acknowledge.

Author's Address

   Subodh Iyengar
   Facebook

   Email: subodh@fb.com
