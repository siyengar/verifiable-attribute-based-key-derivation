



cfrg                                                          S. Iyengar
Internet-Draft                                                  Facebook
Intended status: Informational                          21 February 2021
Expires: 25 August 2021


   Verifiable Oblivious Pseudo-Random Functions with Public Metadata
                draft-iyengar-cfrg-voprfmetadata-latest

Abstract

   This document describes a verifable mechansim to bind public metadata
   to an existing Verifiable oblivious Pseduo-Random function
   [I-D.irtf-cfrg-voprf].  Using zero knowledge proofs a receiver can
   verify that, for an input x, a VOPRF(k, x, metadata), is generated
   from a secret key k, as well as the given metadata.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the Crypto Forum Research
   Group mailing list (cfrg@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=cfrg.

   Source for this draft and an issue tracker can be found at
   https://github.com/siyengar/verifiable-attribute-based-key-
   derivation.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 25 August 2021.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements
     1.2.  Terminology
   2.  Preliminaries
   3.  Protocol
     3.1.  Setup
     3.2.  Other Context APIs
   4.  Comparison with other approaches
     4.1.  Pairings
     4.2.  Regular key derivation
   5.  Security Considerations
     5.1.  Cryptographic security
       5.1.1.  Hardness assumptions
     5.2.  Selective security vs full security
   6.  IANA Considerations
   7.  Normative References
   Acknowledgments
   Author's Address

1.  Introduction

   A VOPRF allows a client and server to evaluate a psuedo-random
   function "F(k, x)", with secret key "k", and input "x" without the
   client learning the key "k" and the server learning the input "x".
   Additionally in a VOPRF, the client can verify that the output was
   computed using the key "k" and not some other key.

   One challenge in VOPRFs is to be able to bind public metadata to the
   output of the VOPRF while keeping the VOPRF both verifiable and
   oblivious.  Unlike the input x to the VOPRF, public metadata is not
   meant to be secret to either the client or the server.  This public
   metadata is useful in applications where being able to bind
   application context to a VOPRF output is criticial to the security of
   the application.

   In this draft we describe a mechanism to bind public metadata to a
   VOPRF using a specific public key derived from the metadata.  The
   mechanism of how metadata is used is left to the specific
   application.

1.1.  Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

1.2.  Terminology

   The following terms are used throughout this document.

   *  PRF: Pseudorandom Function.

   *  VOPRF: Verifiable Oblivious Pseudorandom Function.

   *  Client: Protocol initiator.  Learns pseudorandom function
      evaluation as the output of the protocol.

   *  Server: Computes the pseudorandom function over a secret key.
      Learns nothing about the client's input.

   *  NIZK: Non-interactive zero knowledge.

   *  DLEQ: Discrete Logarithm Equality.

2.  Preliminaries

   TODO: describe the definition of metadata define sampling define
   functions that are used

3.  Protocol

   ## Overview A server first generates a main key pair "(skM, pkM)",
   where "skM" is the servers main secret key and "pkM" is the servers
   main public key.  Given public metadata "t", the server generates a
   keypair specific to the metadata "t", "(skT, pkT) = PKGen(t, skM)",
   where "skT" is the secret key for metadata "t" and "pkT" is its
   public key.  Once a metadata specific keypair is available, the
   server can be used to evaluate a "VOPRF(skT, x)", where "x" is the
   input for the user.  When the VOPRF is in verifiable mode, the client
   also receives a NIZK proof that "skT" is generated from "skM".

   Client(pkM, input, metadata)        Server(skM, pkM, metadata)
  ----------------------------------------------------------
    blind, blindedElement = Blind(input)

                       blindedElement
                        ---------->
         skT, pkT, pk_proof = PKGen(skM, metadata)

    evaluatedElement, proof = Evaluate(skT, pkT, blindedElement)

                  evaluatedElement, pkT, proof, pk_proof
                        <----------

    pk_verified = PKVerify(pkM, pkT, pk_proof)

    output = Finalize(input, blind, evaluatedElement, blindedElement, pkT, proof)

   In the following sections we describe modifications to the VOPRF
   scheme in [I-D.irtf-cfrg-voprf] to be able to augment an existing
   VOPRF with public metadata.

3.1.  Setup

   We augment the offline context setup phase phase of the VOPRF in
   [I-D.irtf-cfrg-voprf].  In this phase, both the client and server
   create a context used for executing the online phase of the protocol.

   Prior to this phase, the key pair ("skM", "pkM") should be generated
   by using "MasterKeyGen(metadata_bits)".

   def MasterKeyGen(metadata_bits):
       skElements = []
       pkElements = []
       h = NewGroupGenerator()
       a0 = RandomScalar()
       for i in range(metadata_bits):
           ai = RandomScalar()
           skElements.append(ai)
       for i in range(metadata_bits):
           hi = h.ScalarMult(skElements[i])
           pkElements.append(hi)
       P0 = g.ScalarMult(a0)
       skM = (a0, skElements)
       pkM = (G, g, h, metadata_bits, P0, pkElements)
       return (skM, pkM)

   "metadata_bits" here is the number of bits of metadata that are
   required for the application of the VOPRF.  "MasterKeyGen" samples
   "n" scalar elements "a0, a1, ... an" from the group and a new
   generator "h".  Public parameters are calculated by performing scalar
   multiplicaton of "h" with "ai".

   When client and server have agreed on the metadata to use for the
   protocol, the server executes "PKGen(skM, metadata)" to generate
   "skT" and the proof that "skT" is derived from "skM".

 def PKGen(metadata, skM, pkM):
     pi = skM.a0
     pis = []
     key_bits = len(metadata)
     for i in range(key_bits):
         pi = pi * (skM[i] ^ metadata[i])
         pis.append(pi)
     skT = pi
     pk_proof = GenProof(metadata, pis, pkM)
     return (skT, pk_proof)

 def GenProof(metadata, pis, pkM):
     num_proofs = len(pis)
     proofs = []
     previous_pi = pkM.P0
     for i in range(num_proofs):
         proof_i = DLEQ(pkM.h, pkM.h ^ metadata[i], previous_pi, pis[i])
         proofs.append(proof_i)
     return proofs

3.2.  Other Context APIs

   We describe the changes needed to the other context APIs

4.  Comparison with other approaches

4.1.  Pairings

4.2.  Regular key derivation

5.  Security Considerations

5.1.  Cryptographic security

5.1.1.  Hardness assumptions

5.2.  Selective security vs full security

6.  IANA Considerations

   This document has no IANA actions.

7.  Normative References

   [I-D.irtf-cfrg-voprf]
              Davidson, A., Faz-Hernandez, A., Sullivan, N., and C. A.
              Wood, "Oblivious Pseudorandom Functions (OPRFs) using
              Prime-Order Groups", Work in Progress, Internet-Draft,
              draft-irtf-cfrg-voprf-06, 21 February 2021,
              <https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-
              voprf-06.txt>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://datatracker.ietf.org/doc/html/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://datatracker.ietf.org/doc/html/rfc8174>.

Acknowledgments

   TODO acknowledge.

Author's Address

   Subodh Iyengar
   Facebook

   Email: subodh@fb.com
