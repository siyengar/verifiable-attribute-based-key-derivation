---
title: Verifiable Oblivious Pseudo-Random Functions with Public Metadata
abbrev: "TODO - Abbreviation"
docname: draft-iyengar-cfrg-voprfmetadata-latest
category: info

ipr: trust200902
area: irtf
workgroup: cfrg
keyword: Internet-Draft

stand_alone: yes
smart_quotes: no
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: S. Iyengar
    name: Subodh Iyengar
    organization: Facebook
    email: subodh@fb.com

normative:
  RFC2119:

informative:



--- abstract

This document describes a verifable mechansim to bind public metadata to an
existing Verifiable oblivious Pseduo-Random function {{!I-D.irtf-cfrg-voprf}}.
Using zero knowledge proofs a receiver can verify that, for an input x, a
VOPRF(k, x, metadata), is generated from a secret key k, as well as the given
metadata.

--- middle

# Introduction

A VOPRF allows a client and server to evaluate a psuedo-random function
`F(k, x)`, with secret key `k`, and input `x` without the client learning the
key `k` and the server learning the input `x`.  Additionally in a VOPRF, the
client can verify that the output was computed using the key `k` and not some
other key.

One challenge in VOPRFs is to be able to bind public metadata to the output
of the VOPRF while keeping the VOPRF both verifiable and oblivious.
Unlike the input x to the VOPRF, public metadata is not meant
to be secret to either the client or the server.  This public metadata is
useful in applications where being able to bind application context to a VOPRF
output is criticial to the security of the application.

In this draft we describe a mechanism to bind public metadata to a VOPRF using
a specific public key derived from the metadata.  The mechanism of how metadata
is used is left to the specific application.

## Requirements

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14 {{RFC2119}} {{!RFC8174}}
when, and only when, they appear in all capitals, as shown here.

## Terminology
The following terms are used throughout this document.

- PRF: Pseudorandom Function.
- VOPRF: Verifiable Oblivious Pseudorandom Function.
- Client: Protocol initiator. Learns pseudorandom function evaluation as
  the output of the protocol.
- Server: Computes the pseudorandom function over a secret key. Learns
  nothing about the client's input.
- NIZK: Non-interactive zero knowledge.
- DLEQ: Discrete Logarithm Equality.

# Preliminaries
TODO: describe the definition of metadata
define sampling
define functions that are used

# Protocol
## Overview
A server first generates a main key pair `(skM, pkM)`, where `skM` is the
servers main secret key and `pkM` is the servers main public key.
Given public metadata `t`, the server generates a keypair specific to the
metadata `t`, `(skT, pkT) = PKGen(t, skM)`, where `skT` is the secret key for
metadata `t` and `pkT` is its public key. Once a metadata specific keypair is
available, the server can be used to evaluate a `VOPRF(skT, x)`, where `x` is
the input for the user.  When the VOPRF is in verifiable mode, the client also
receives a NIZK proof that `skT` is generated from `skM`.

~~~
   Client(pkM, input, metadata)        Server(skM, pkM, metadata)
  ----------------------------------------------------------
    blind, blindedElement = Blind(input)

                       blindedElement
                        ---------->
         skT, pkT, pk_proof = PKGen(skM, metadata)

    evaluatedElement, proof = Evaluate(skT, pkT, blindedElement)

                  evaluatedElement, pkT, proof, pk_proof
                        <----------

    pk_verified = PKVerify(pkM, pkT, pk_proof)

    output = Finalize(input, blind, evaluatedElement, blindedElement, pkT, proof)
~~~

In the following sections we describe modifications to the VOPRF scheme in
{{!I-D.irtf-cfrg-voprf}} to be able to augment an existing VOPRF with public
metadata.

## Setup
We augment the offline context setup phase phase of the VOPRF in
{{!I-D.irtf-cfrg-voprf}}. In this phase, both the client and server create a
context used for executing the online phase of the protocol.

Prior to this phase, the key pair
(`skM`, `pkM`) should be generated by using `MasterKeyGen(metadata_bits)`.

~~~
def MasterKeyGen(metadata_bits):
    skElements = []
    pkElements = []
    h = NewGroupGenerator()
    a0 = RandomScalar()
    for i in range(metadata_bits):
        ai = RandomScalar()
        skElements.append(ai)
    for i in range(metadata_bits):
        hi = h.ScalarMult(skElements[i])
        pkElements.append(hi)
    P0 = g.ScalarMult(a0)
    skM = (a0, skElements)
    pkM = (G, g, h, metadata_bits, P0, pkElements)
    return (skM, pkM)
~~~

`metadata_bits` here is the number of bits of metadata that are required for
the application of the VOPRF.  `MasterKeyGen` samples `n` scalar elements
`a0, a1, ... an` from the group and a new generator `h`.  Public parameters
are calculated by performing scalar multiplicaton of `h` with `ai`.

When client and server have agreed on the metadata to use for the protocol,
the server executes `PKGen(skM, metadata)` to generate `skT` and the proof
that `skT` is derived from `skM`.

~~~
def PKGen(metadata, skM, pkM):
    pi = skM.a0
    pis = []
    key_bits = len(metadata)
    for i in range(key_bits):
        pi = pi * (skM[i] ^ metadata[i])
        pis.append(pi)
    skT = pi
    pk_proof = GenProof(metadata, pis, pkM)
    return (skT, pk_proof)

def GenProof(metadata, pis, pkM):
    num_proofs = len(pis)
    proofs = []
    previous_pi = pkM.P0
    for i in range(num_proofs):
        proof_i = DLEQ(pkM.h, pkM.h ^ metadata[i], previous_pi, pis[i])
        proofs.append(proof_i)
    return proofs
~~~

## Other Context APIs
We describe the changes needed to the other context APIs

# Comparison with other approaches

## Pairings

## Regular key derivation

# Security Considerations

## Cryptographic security

### Hardness assumptions



## Selective security vs full security


# IANA Considerations

This document has no IANA actions.

--- back

# Acknowledgments
{:numbered="false"}

TODO acknowledge.
